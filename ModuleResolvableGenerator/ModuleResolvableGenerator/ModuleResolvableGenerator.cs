using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ModuleResolvableGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class ModuleResolvableGenerator : IIncrementalGenerator
{
    const string Ns = "Ulenv";
    const string Atr = "ModuleResolvableAttribute";
    const string AtrDisp = $"{Ns}.{Atr}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx => ctx.AddSource($"{Ns}.ModuleResolvable.g.cs", PostAtr()));

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            AtrDisp,
            static (node, token) => node is ClassDeclarationSyntax,
            static (context, token) => context
        );
        context.RegisterSourceOutput(source, Emit);
    }

    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;
        var className = typeSymbol.Name;

        var accessibility = typeSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            _ => null,
        };
        if (string.IsNullOrEmpty(accessibility))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.E0001, typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        if (!typeNode.Modifiers.Any(x => x.IsKind(SyntaxKind.PartialKeyword)))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.E0002, typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var count = GetCustomHash(typeSymbol.ToDisplayString());
        var loop = 0uL;
        foreach (var atr in typeSymbol.GetAttributes())
        {
            if (atr?.AttributeClass?.ToDisplayString() == AtrDisp &&
                atr.ConstructorArguments.Length > 0)
            {
                loop = ulong.Parse(atr.ConstructorArguments[0].Value!.ToString());
            }
        }

        var isNamespace = !typeSymbol.ContainingNamespace.IsGlobalNamespace;

        context.AddSource($"{className}.ModuleResolvable.g.cs", $$"""
// <auto-generated/>
using System.Runtime.CompilerServices;
using Ulenv;
{{(isNamespace ? $$"""namespace {{typeSymbol.ContainingNamespace}} {""" : "")}}
{{accessibility}} partial class {{className}} : IModuleResolvable
{
    public static Unique Unique => new({{count}}, {{loop}});
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public ModuleAddScope Resolve(IModuleMap moduleMap) => moduleMap.AddScoped(Unique, this);
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{className}} From(IModuleMap moduleMap) => ({{className}})moduleMap[Unique];
}
{{(isNamespace ? "}" : "")}}
""");
    }

    static ulong GetCustomHash(string str)
    {
        ulong hash = 0;
        for (int i = 0; i < str.Length; i++)
        {
            hash *= 31;
            hash += str[i];
        }
        return hash;
    }

    static string PostAtr()
    {
        return $$"""
// <auto-generated/>
using System;
namespace {{Ns}}
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    internal sealed class {{Atr}} : Attribute
    {
        /// <param name="loop">second argument of 'Unique' constructor.</param>
        public {{Atr}}(ulong loop) { }
    }
}
""";
    }
}
