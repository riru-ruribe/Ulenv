using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ModuleResolvableGenerator;

[Generator(LanguageNames.CSharp)]
public sealed class ModuleResolvableGenerator : IIncrementalGenerator
{
    const string Ns = "Ulenv";
    const string Atr = "ModuleResolvableAttribute";
    const string AtrDisp = $"{Ns}.{Atr}";
    const string MonoDisp = "UnityEngine.MonoBehaviour";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static ctx => ctx.AddSource($"{Ns}.ModuleResolvable.g.cs", PostAtr()));

        var source = context.SyntaxProvider.ForAttributeWithMetadataName(
            AtrDisp,
            static (node, token) => node is ClassDeclarationSyntax or InterfaceDeclarationSyntax,
            static (context, token) => context
        );
        context.RegisterSourceOutput(source, Emit);
    }

    static void Emit(SourceProductionContext context, GeneratorAttributeSyntaxContext source)
    {
        var typeSymbol = (INamedTypeSymbol)source.TargetSymbol;
        var typeNode = (TypeDeclarationSyntax)source.TargetNode;
        var className = typeSymbol.Name;

        var accessibility = typeSymbol.DeclaredAccessibility switch
        {
            Accessibility.Public => "public",
            _ => null,
        };
        if (string.IsNullOrEmpty(accessibility))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.E0001, typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        if (!typeNode.Modifiers.Any(x => x.IsKind(SyntaxKind.PartialKeyword)))
        {
            context.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.E0002, typeNode.Identifier.GetLocation(), typeSymbol.Name));
            return;
        }

        var count = GetCustomHash(typeSymbol.ToDisplayString());
        var loop = 0uL;
        foreach (var atr in typeSymbol.GetAttributes())
        {
            if (atr?.AttributeClass?.ToDisplayString() == AtrDisp &&
                atr.ConstructorArguments.Length > 0)
            {
                loop = ulong.Parse(atr.ConstructorArguments[0].Value!.ToString());
            }
        }

        var isNamespace = !typeSymbol.ContainingNamespace.IsGlobalNamespace;

        context.AddSource($"{className}.ModuleResolvable.g.cs", $$"""
// <auto-generated/>
using System.Runtime.CompilerServices;
using Ulenv;
{{(isNamespace ? $$"""namespace {{typeSymbol.ContainingNamespace}} {""" : "")}}
{{accessibility}} partial {{typeNode.Keyword}} {{className}} : IResolvable
{
    Unique IResolvable.Unique => new({{count}}, {{loop}});
}
{{accessibility}} static class _{{count}}_{{loop}}
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static {{className}} {{className}}(this IModuleMap moduleMap) => ({{className}})moduleMap[new({{count}}, {{loop}})];
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool {{className}}(this IModuleMap moduleMap, out {{className}} value) => moduleMap.TryGetValue(new({{count}}, {{loop}}), out value);
}
{{(isNamespace ? "}" : "")}}
""");
    }

    static ulong GetCustomHash(string str)
    {
        ulong hash = 0;
        for (int i = 0; i < str.Length; i++)
        {
            hash *= 31;
            hash += str[i];
        }
        return hash;
    }

    static string PostAtr()
    {
        return $$"""
// <auto-generated/>
using System;
namespace {{Ns}}
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false)]
    internal sealed class {{Atr}} : Attribute
    {
        /// <param name="loop">second argument of 'Unique' constructor.</param>
        public {{Atr}}(ulong loop) { }
    }
}
""";
    }
}
